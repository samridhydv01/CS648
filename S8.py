import random as rd
import math
import numpy as np
from statistics import mean
import itertools

#Kronecker's delta function
def delta(m,n): return 1 if m == n else 0

#i^{th} vector in the standard basis of \R^n
def e(i, n): return [delta(i, j) for j in range(n)]

#Samples a point uniformly randomly from T^n \subseteq \R^{n+1}
def samp(n):
    L = [rd.random() for i in range(n)]
    return L+[1-sum(L)]	if sum(L) <= 1 else samp(n)

#Given n+1 vertices in \R^{n+1}, computes the n volume of the n-simplex generated by them
def vol(verts):
    return abs(np.linalg.det(verts)/math.sqrt(len(verts)))


# print(mean([vol([e(i, 2) for i in range(2)]) for j in range(500)]))

#Standard code to iterate over subsets
def iterate_over_subsets(list1, n):
  for subset in itertools.combinations(list1, n):
    yield subset

# Given a list lst of points in \R^{n+1}, returns the smallest n-volume among the n-volumes of n-simplices generated by n element subsets of lst
def volumes(lst, n):
  M = 300
  for subset in iterate_over_subsets(lst, n + 1):
    M = min(M, vol(subset))
  return M


# print(mean([volumes([e(i, 2) for i in range(2)] + [samp(1) for i in range (4)], 1) for j in range(500)])/vol([e(i, 2) for i in range(2)]))

# Number of runs of the experiment, increase to increase accuracy
def steps(n):
    if n > 10:
        return 500
    return 2000

# Computes S^m_n
def S(m, n):
    return mean([volumes([e(i, m + 1) for i in range(m + 1)] + [samp(m) for i in range (n)], m) for j in range(steps(n))])

# Computes the volume of T^m
def T(m):
    return vol([e(i, m+1) for i in range(m+1)])

# Computes M_{m, n}
def M(m, n):
    return S(m, n)/T(m)

# Closest integer function
def closest_integer(number):
  if number % 1 < 0.5:
    return int(number)
  else:
    return int(number + 1)

# Prints M_{m, n} for small m, n
def run(k):
    for m in range (k):
        for n in range(5):
            print("{:.5f}".format(M(m, n)), end=' ')
        print()
        
# Prints 1/(M_{m, n}) for small m, n
def intrun(k):
    for m in range (k):
        for n in range(5):
            print(closest_integer(1/M(m, n)), end=' ')
        print()

# Prints M_{2, n} 
# for n in range(100):
#     print(n, M(2, n))
